# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import pydantic_v1
from ..core.request_options import RequestOptions
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .types.asset_type import AssetType
from .types.base_engine import BaseEngine
from .types.base_engine_type import BaseEngineType
from .types.complete_asset_upload_response import CompleteAssetUploadResponse
from .types.create_asset_response import CreateAssetResponse
from .types.data import Data
from .types.data_type import DataType
from .types.delete_asset_response import DeleteAssetResponse
from .types.http_validation_error import HttpValidationError
from .types.list_assets_response import ListAssetsResponse
from .types.retrieve_asset_response import RetrieveAssetResponse
from .types.transfer_api_type import TransferApiType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AssetLibraryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        name: typing.Optional[str] = None,
        is_public: typing.Optional[bool] = None,
        data_type: typing.Optional[DataType] = None,
        asset_type: typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]] = None,
        engine: typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]] = None,
        engine_type: typing.Optional[BaseEngineType] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        get_preview_urls: typing.Optional[bool] = None,
        asset_ids: typing.Optional[str] = None,
        owner: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListAssetsResponse:
        """
        List assets with optional filtering.

        Parameters
        ----------
        name : typing.Optional[str]
            Filter based on asset name.

        is_public : typing.Optional[bool]
            Filter based on asset visibility.

        data_type : typing.Optional[DataType]
            Filter based on data type.

        asset_type : typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]]
            Filter based on engine type.

        engine : typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]]
            Filter based on engine.

        engine_type : typing.Optional[BaseEngineType]
            Filter based on engine type.

        limit : typing.Optional[int]
            Max number of assets to return.

        offset : typing.Optional[int]
            Offset to start listing assets.

        get_preview_urls : typing.Optional[bool]
            Include preview URLs for assets.

        asset_ids : typing.Optional[str]
            Filter based on asset IDs.

        owner : typing.Optional[str]
            Filter based on asset owener.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListAssetsResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/assets",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={
                "name": name,
                "is_public": is_public,
                "data_type": data_type,
                "asset_type": asset_type,
                "engine": engine,
                "engine_type": engine_type,
                "limit": limit,
                "offset": offset,
                "get_preview_urls": get_preview_urls,
                "asset_ids": asset_ids,
                "owner": owner,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ListAssetsResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        asset_type: AssetType,
        data: Data,
        name: str,
        description: typing.Optional[str] = OMIT,
        hf_repo: typing.Optional[str] = OMIT,
        hf_token_secret: typing.Optional[str] = OMIT,
        is_public: typing.Optional[bool] = OMIT,
        skip_validation: typing.Optional[bool] = OMIT,
        transfer_api_type: typing.Optional[TransferApiType] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateAssetResponse:
        """
        Create an asset on the asset library.

        Parameters
        ----------
        asset_type : AssetType

        data : Data
            Asset data. It shows the type of data for an asset.

        name : str
            Asset name. A unique name for the asset.

        description : typing.Optional[str]
            Asset description. It is used to provide more information.

        hf_repo : typing.Optional[str]
            HuggingFace repository.

        hf_token_secret : typing.Optional[str]
            OctoAI secret name for HuggingFace token.

        is_public : typing.Optional[bool]
            True if asset is public.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        transfer_api_type : typing.Optional[TransferApiType]
            Transfer API type.

        url : typing.Optional[str]
            Upload the contents of the url as the asset.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateAssetResponse
            Successful Response

        Examples
        --------
        from octoai.asset_library import Data_Checkpoint
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.create(
            asset_type="file",
            data=Data_Checkpoint(
                data_type="fp16",
                engine="text/llama-2-7b",
                file_format="safetensors",
            ),
            description="string",
            hf_repo="string",
            hf_token_secret="string",
            is_public=True,
            name="string",
            skip_validation=True,
            transfer_api_type="presigned-url",
            url="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/assets",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={
                "asset_type": asset_type,
                "data": data,
                "description": description,
                "hf_repo": hf_repo,
                "hf_token_secret": hf_token_secret,
                "is_public": is_public,
                "name": name,
                "skip_validation": skip_validation,
                "transfer_api_type": transfer_api_type,
                "url": url,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CreateAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, asset_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> DeleteAssetResponse:
        """
        Delete an asset from the asset library.

        Parameters
        ----------
        asset_id : str
            The asset unique ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.delete(
            asset_id="asset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_id)}",
            base_url=self._client_wrapper.get_environment().default,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DeleteAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def complete_upload(
        self,
        asset_id: str,
        *,
        skip_validation: typing.Optional[bool] = OMIT,
        token: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteAssetUploadResponse:
        """
        Complete the upload of an asset.

        Parameters
        ----------
        asset_id : str
            The asset unique ID.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        token : typing.Optional[str]
            Unused. User OctoAI token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteAssetUploadResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.complete_upload(
            asset_id="asset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_id)}/complete-upload",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"skip_validation": skip_validation, "token": token},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CompleteAssetUploadResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self,
        asset_owner_and_name_or_id: str,
        *,
        transfer_api_type: typing.Optional[TransferApiType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveAssetResponse:
        """
        Retrieve asset with the given owner and name or id.

        Parameters
        ----------
        asset_owner_and_name_or_id : str
            Owner and name or id of the asset.

        transfer_api_type : typing.Optional[TransferApiType]
            Type of transfer API to generate.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.get(
            asset_owner_and_name_or_id="string",
            transfer_api_type="presigned-url",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_owner_and_name_or_id)}",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"transfer_api_type": transfer_api_type},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(RetrieveAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAssetLibraryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        name: typing.Optional[str] = None,
        is_public: typing.Optional[bool] = None,
        data_type: typing.Optional[DataType] = None,
        asset_type: typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]] = None,
        engine: typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]] = None,
        engine_type: typing.Optional[BaseEngineType] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        get_preview_urls: typing.Optional[bool] = None,
        asset_ids: typing.Optional[str] = None,
        owner: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListAssetsResponse:
        """
        List assets with optional filtering.

        Parameters
        ----------
        name : typing.Optional[str]
            Filter based on asset name.

        is_public : typing.Optional[bool]
            Filter based on asset visibility.

        data_type : typing.Optional[DataType]
            Filter based on data type.

        asset_type : typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]]
            Filter based on engine type.

        engine : typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]]
            Filter based on engine.

        engine_type : typing.Optional[BaseEngineType]
            Filter based on engine type.

        limit : typing.Optional[int]
            Max number of assets to return.

        offset : typing.Optional[int]
            Offset to start listing assets.

        get_preview_urls : typing.Optional[bool]
            Include preview URLs for assets.

        asset_ids : typing.Optional[str]
            Filter based on asset IDs.

        owner : typing.Optional[str]
            Filter based on asset owener.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListAssetsResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/assets",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={
                "name": name,
                "is_public": is_public,
                "data_type": data_type,
                "asset_type": asset_type,
                "engine": engine,
                "engine_type": engine_type,
                "limit": limit,
                "offset": offset,
                "get_preview_urls": get_preview_urls,
                "asset_ids": asset_ids,
                "owner": owner,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ListAssetsResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        asset_type: AssetType,
        data: Data,
        name: str,
        description: typing.Optional[str] = OMIT,
        hf_repo: typing.Optional[str] = OMIT,
        hf_token_secret: typing.Optional[str] = OMIT,
        is_public: typing.Optional[bool] = OMIT,
        skip_validation: typing.Optional[bool] = OMIT,
        transfer_api_type: typing.Optional[TransferApiType] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateAssetResponse:
        """
        Create an asset on the asset library.

        Parameters
        ----------
        asset_type : AssetType

        data : Data
            Asset data. It shows the type of data for an asset.

        name : str
            Asset name. A unique name for the asset.

        description : typing.Optional[str]
            Asset description. It is used to provide more information.

        hf_repo : typing.Optional[str]
            HuggingFace repository.

        hf_token_secret : typing.Optional[str]
            OctoAI secret name for HuggingFace token.

        is_public : typing.Optional[bool]
            True if asset is public.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        transfer_api_type : typing.Optional[TransferApiType]
            Transfer API type.

        url : typing.Optional[str]
            Upload the contents of the url as the asset.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateAssetResponse
            Successful Response

        Examples
        --------
        from octoai.asset_library import Data_Checkpoint
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.create(
            asset_type="file",
            data=Data_Checkpoint(
                data_type="fp16",
                engine="text/llama-2-7b",
                file_format="safetensors",
            ),
            description="string",
            hf_repo="string",
            hf_token_secret="string",
            is_public=True,
            name="string",
            skip_validation=True,
            transfer_api_type="presigned-url",
            url="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/assets",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={
                "asset_type": asset_type,
                "data": data,
                "description": description,
                "hf_repo": hf_repo,
                "hf_token_secret": hf_token_secret,
                "is_public": is_public,
                "name": name,
                "skip_validation": skip_validation,
                "transfer_api_type": transfer_api_type,
                "url": url,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CreateAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, asset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteAssetResponse:
        """
        Delete an asset from the asset library.

        Parameters
        ----------
        asset_id : str
            The asset unique ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.delete(
            asset_id="asset_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_id)}",
            base_url=self._client_wrapper.get_environment().default,
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DeleteAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def complete_upload(
        self,
        asset_id: str,
        *,
        skip_validation: typing.Optional[bool] = OMIT,
        token: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteAssetUploadResponse:
        """
        Complete the upload of an asset.

        Parameters
        ----------
        asset_id : str
            The asset unique ID.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        token : typing.Optional[str]
            Unused. User OctoAI token.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteAssetUploadResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.complete_upload(
            asset_id="asset_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_id)}/complete-upload",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"skip_validation": skip_validation, "token": token},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CompleteAssetUploadResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self,
        asset_owner_and_name_or_id: str,
        *,
        transfer_api_type: typing.Optional[TransferApiType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveAssetResponse:
        """
        Retrieve asset with the given owner and name or id.

        Parameters
        ----------
        asset_owner_and_name_or_id : str
            Owner and name or id of the asset.

        transfer_api_type : typing.Optional[TransferApiType]
            Type of transfer API to generate.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.get(
            asset_owner_and_name_or_id="string",
            transfer_api_type="presigned-url",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/assets/{jsonable_encoder(asset_owner_and_name_or_id)}",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"transfer_api_type": transfer_api_type},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(RetrieveAssetResponse, _response.json())  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
